// Minimizing 3E2BCDCD-FCDC-4220-B4A1-C95D0C2722BD
-"function";
const v4 = ("function").length;
v4 != v4;
try {
    ("a")[0];
    ("function").replace("function", "a");
} catch(e9) {
}
7.727398408749511e+307 >>> 7.727398408749511e+307;
new BigInt64Array(6);
const v19 = new Int8Array(1024);
const v20 = v19?.constructor;
try { new v20(3.0, 3.0, v19); } catch (e) {}
119 - 119;
new Uint16Array(119);
const t16 = "function";
t16.toString = 7.727398408749511e+307;
function f26() {
    return Int8Array;
}
try { new f26(); } catch (e) {}
let v28 = {};
v28.e = v28;
v28.e = f26;
const v29 = {};
v29.e = f26;
v29.f = 3.0;
const v30 = {};
v30.g = v30;
v30.e = f26;
v30.f = 3.0;
v30.h = Int8Array;
const v31 = {};
v31.h = v31;
v31.e = f26;
v31.f = 3.0;
v31.b = 119;
function f32(a33, a34, a35) {
    a33[3] = 6;
    if (0.16106926571477698 !== 512) {
    }
    try {
        v30 + 7.727398408749511e+307;
        Uint8Array.BYTES_PER_ELEMENT = Uint8Array;
        const v42 = new Uint8Array(1);
        try { v42.sort(v28); } catch (e) {}
    } finally {
        function F44(a46) {
            if (!new.target) { throw 'must be called with new'; }
        }
        try {
            const v47 = ("e").lastIndexOf(a34, a33);
            v47 / v47;
        } catch(e49) {
        }
    }
    1 >>> 1;
    new Int8Array(1);
    const v56 = new Float64Array(11);
    const v57 = v56.sort;
    v57.name = v57;
    new Int16Array(1548);
    new BigUint64Array(3);
    255 / 255;
    new Uint32Array(255);
    v31[905757355] /= -3.0;
    const v68 = {};
    return a35;
}
try { new Int16Array("e", "e", Int16Array); } catch (e) {}
const v73 = new Uint8Array(2);
let v74 = 1633;
const v76 = [1000000.0,-8.228668493097701e+307,-5.0,-2.0,-2.220446049250313e-16,8.266281210353355];
v74 ^= 2;
function f77(a78, a79) {
    a78 - a78;
    a79 ?? a79;
    const v83 = `1645374161`;
    -2147483647 - /a\bc/mvd;
    const v89 = new Int32Array(160);
    v89[64] >>>= 160;
    new Int16Array();
    v89.length += 2;
    const v94 = new BigUint64Array(512);
    function f95() {
    }
    const v96 = v89.findLast(f95, v76);
    v96 ?? v96;
    v73.byteOffset *= 2;
    try { Math.min(v83, BigUint64Array); } catch (e) {}
    class C101 {
    }
    const v104 = [SharedArrayBuffer,Reflect];
    const v105 = v104?.constructor;
    try { new v105(v94); } catch (e) {}
    Reflect.construct(SharedArrayBuffer, v104);
    Math.log10(undefined);
    return v74;
}
for (let v109 = 0; v109 < 25; v109++) {
    f77(v109);
}
for (let v111 = 0; v111 < 100; v111++) {
    f32(119, f77, -3.0);
}
let v113 = 10;
const v116 = new Float32Array(175);
v116.byteOffset = v116;
Math.round(-1e-15);
for ((() => {
        Math[v31];
        delete v28?.e;
        const v122 = -3.0;
        v122 + v122;
        let v125 = 16;
        v125--;
        const v127 = v125--;
        Math.atan2(v125, v127);
        Math.trunc(v74);
        const v130 = --v125;
        const v131 = Math.pow(v127, v127);
        v131 << v131;
        const v134 = (v74 / v130) ** v127;
        v134 - v134;
    })();
    v113--;
    ) {
    const v141 = typeof f32 === "string";
    break;
    v113 = v141;
    let v142 = v28 >> -53468;
    const v143 = v142--;
    Math.log10(v142);
    const v146 = !(v28--);
    -v143;
    Math.cosh(v146);
}
const v149 = f32(2, 6, -3.0);
for (let v150 = 0; v150 < 100; v150++) {
    v150 % v150;
    const v152 = f32(v150, v150, v113);
    v152 % v152;
}
try { Math.floor(v29); } catch (e) {}
let v156 = 2054825424;
v156 * v156;
let v158 = -1;
v158--;
f26 ?? v158;
v156++;
const v162 = Math.expm1("e");
try { Uint32Array.from(7.727398408749511e+307); } catch (e) {}
const v166 = this?.decompileThis;
try { new v166(); } catch (e) {}
const v168 = this[Uint32Array];
v168 ?? v168;
("function").split("object")[0];
const v173 = f32(2, v162, v149);
v173 >> v173;
gc();
// Program is interesting due to new coverage: 24 newly discovered edges in the CFG of the target
