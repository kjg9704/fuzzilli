// Minimizing E9DCCF73-1D63-49AE-8C25-61C1D55C54E2
const v2 = new Uint8Array(1000);
var a = v2;
const v5 = a.fill(255);
const v6 = a.sort();
function F7(a9, a10, a11) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = 1000;
    this.g = a10;
    this.c = v6;
}
const v12 = new F7(1000, v5, v2);
const v13 = new F7(F7, v12, a);
const v14 = new F7(a, v13, 1000);
class C18 {
    static [v6];
    set c(a20) {
        v14.valueOf = a20;
        new Proxy(a, {});
        F7 >>> a20;
    }
    g;
    2584;
    static #d;
}
new C18();
new C18();
new C18();
const v30 = new Int8Array(256);
const v36 = v13[-52211];
function F37(a39, a40) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = a40;
}
new F37(v13, 0.314538170130528);
const v42 = new F37(v12, v36);
new F37(v12, v36);
const v44 = new Int8Array(10);
new Uint8ClampedArray(72);
const v50 = ("1328108000").normalize("NFD");
const v52 = ("345328426").normalize();
for (let [i65, i66] = (() => {
        let v53;
        try { v53 = v36(Uint8Array, F7); } catch (e) {}
        v42[delete v53?.[72]];
        const v60 = new SharedArrayBuffer(127, { maxByteLength: 65536 });
        new Uint16Array(v60);
        return [0, 10];
    })();
    i65 < i66;
    i65++, i66--) {
    const v76 = new Int16Array(129);
    const v79 = new Uint32Array(2);
    v79.lastIndexOf();
    try {
        v76.keys();
    } catch(e82) {
    }
    new BigInt64Array(2);
}
const v86 = [-2,694104526,127,-31678,-59074,1543,9];
let v87 = [715,1073741824,4294967295,-14674,56363,-97302905,2,1717658487,8];
[-1781759842,-1701358423,7,-1523648348];
const v89 = delete v87.length;
v87 %= v89;
const v105 = {
    e: v89,
    ..."1328108000",
    g: "NFD",
    2: v30,
    __proto__: C18,
    f: 72,
    c: v44,
    valueOf(a91, a92) {
        class C93 {
        }
        super.d;
        function f95(a96, a97, a98, a99) {
            ([-1000000000.0,-1.7976931348623157e+308,994.8821030908791,-691.4042279925482,0.3591429101168231,62.2078428497,0.21110210033372545]).__proto__;
            +Float64Array;
            return v86;
        }
        f95(a91, v13, C93, this);
        return v52;
    },
};
const v107 = [9007199254740991];
function f108(a109, a110, a111) {
    return v107;
}
for (let v112 = 0; v112 < 100; v112++) {
    f108("345328426", v50, v5);
}
function f114() {
    return Int8Array;
}
new Float64Array();
class C117 {
    constructor(a119, a120) {
        for (const v121 in this) {
        }
    }
}
const v122 = v14 >> v5;
("OO").startsWith("has", -715099968);
let v127 = 2;
const v129 = new Uint32Array(v127);
v129.lastIndexOf();
const v133 = Float64Array * -8;
[,f108,...v127] = v50;
Math.abs([-0.0,-3.0] & -2147483649);
const v148 = {
    d: v5,
    f: Float64Array,
    __proto__: "has",
    ...v2,
    7: v122,
    set e(a140) {
    },
    get e() {
        const v142 = {};
        try { Int16Array(); } catch (e) {}
        return Uint8Array;
    },
    [72](a146, a147) {
    },
    1507631625: v133,
    [v89]: v129,
    e: F7,
    d: v50,
};
gc();
// Program is interesting due to new coverage: 7 newly discovered edges in the CFG of the target
// Imported program is interesting due to new coverage: 210 newly discovered edges in the CFG of the target
